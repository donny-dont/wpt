<!DOCTYPE html>
<html>
<head>
<title>MediaStream Insertable Streams - Video</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
</head>
<body>
<script>

function makeVideoFrame(timestamp) {
      const height = 10;
      const width = 10;
      let canvas = new OffscreenCanvas(width, height);

      let ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgba(50, 100, 150, 255)';
      ctx.fillRect(0, 0, width, height);

      return new VideoFrame(canvas.transferToImageBitmap(), { timestamp });
    }

async function getVideoFrame() {
  const stream = await navigator.mediaDevices.getUserMedia({video: true});
  const input_track = stream.getTracks()[0];
  const processor = new MediaStreamTrackProcessor(input_track);
  const reader = processor.readable.getReader();
  const result = await reader.read();
  input_track.stop();
  return result.value;
}

promise_test(async t => {
  const videoFrame = await getVideoFrame();
  const originalWidth = videoFrame.displayWidth;
  const originalHeight = videoFrame.displayHeight;
  const originalTimestamp = videoFrame.timestamp;
  const generator = new MediaStreamTrackGenerator({kind: 'video'});

  // Use a MediaStreamTrackProcessor as a sink for |generator| to verify
  // that |processor| actually forwards the frames written to its writable
  // field.
  const processor = new MediaStreamTrackProcessor(generator);
  const reader = processor.readable.getReader();
  const readerPromise = new Promise(async resolve => {
    const result = await reader.read();
    assert_equals(result.value.displayWidth, originalWidth);
    assert_equals(result.value.displayHeight, originalHeight);
    assert_equals(result.value.timestamp, originalTimestamp);
    resolve();
  });

  generator.writable.getWriter().write(videoFrame);
  return readerPromise;
}, 'MediaStreamTrackGenerator forwards frames to sink');


promise_test(async t => {
  let generator = new MediaStreamTrackGenerator("video");

  let writer = generator.writable.getWriter();
  let frame = makeVideoFrame(1);
  await writer.write(frame);

  assert_equals(generator.kind, "video");
  assert_equals(generator.readyState, "live");
}, "Tests that creating a Video MediaStreamTrackGenerator works as expected");

    promise_test(async t => {
      let generator = new MediaStreamTrackGenerator("video");

      let writer = generator.writable.getWriter();
      let frame = makeVideoFrame(1);
      await writer.write(frame);

      assert_throws_dom("InvalidStateError", () => frame.clone(), "VideoFrame wasn't destroyed on write.");
    }, "Tests that VideoFrames are destroyed on write.");

    promise_test(async t => {
      const capturedStream = await navigator.mediaDevices.getUserMedia({ video: true });
      assert_equals(capturedStream.getVideoTracks().length, 1);
      let upstreamTrack = capturedStream.getVideoTracks()[0];

      // Note: needs the new constructor signature, currently not implemented.
      let generator = new MediaStreamTrackGenerator({ signalTarget: upstreamTrack });

      let writer = generator.writable.getWriter();
      let frame = makeVideoFrame(1);
      await writer.write(frame);

      assert_equals(generator.kind, "video");
      assert_equals(generator.readyState, "live");
    }, "Tests that creating a Video MediaStreamTrackGenerator with a signal target works as expected");


    promise_test(async t => {
      let generator = new MediaStreamTrackGenerator("audio");

      let writer = generator.writable.getWriter();
      let frame = makeVideoFrame(1);
      assert_throws_js(TypeError, writer.write(frame));
    }, "Mismatched frame and generator kind throws on write.");
  </script>
</body>
</html>
